# Standalone file: do not edit by hand
# Source: https://github.com/terminological/ggrrr/blob/HEAD/R/standalone-stack-tools.R
# Generated by: usethis::use_standalone("terminological/ggrrr", "stack-tools")
# ----------------------------------------------------------------------
#
# ---
# repo: terminological/ggrrr
# file: standalone-stack-tools.R
# last-updated: '2025-09-21'
# license: https://unlicense.org
# imports:
# - rlang
# - testthat
# ---

#' Permissive as_function replacement.
#'
#' like `rlang::as_function` but only interprets functions or formulae
#' and ignores primitives and characters.
#'
#' @param fn something to interpret as a function or a primitive
#'
#' @returns the function or primitive
#' @keywords internal
#'
#' @unit
#'
#' f1 = .lax_as_function(tolower)
#' f2 = .lax_as_function(~ tolower(.x))
#' f3 = .lax_as_function("hello world")
#'
#' testthat::expect_equal(f1, tolower)
#' testthat::expect_equal(f2("HELLO WORLD"), f1("HELLO WORLD"))
#' testthat::expect_equal(f3, f1("HELLO WORLD"))
#'
.lax_as_function = function(fn) {
  try(if (is.function(fn)) return(fn), silent = TRUE)
  try(if (rlang::is_formula(fn)) return(rlang::as_function(fn)), silent = TRUE)
  return(fn)
}

#' Get the defined name of a function
#'
#' @param fn a function
#'
#' @returns the name as a string, as the function was defined
#' @keywords internal
#'
#' @unit
#'
#' f = tolower
#'
#' testthat::expect_equal(
#'   .get_fn_name(f),
#'   .get_fn_name(tolower)
#' )
#'
#' testthat::expect_equal(
#'   .get_fn_name(.get_fn_name),
#'   ".get_fn_name"
#' )
#'
#' testthat::expect_equal(
#'   .get_fn_name(function(x) x),
#'   "<unknown>"
#' )
#'
.get_fn_name = function(fn) {
  if (is.null(fn)) {
    return("<unknown>")
  }
  fnenv = as.list(rlang::fn_env(fn), all.names = TRUE)
  fnenv = fnenv[sapply(fnenv, is.function)]
  matches = sapply(fnenv, identical, fn)
  if (any(matches)) {
    return(paste0(names(fnenv)[matches], collapse = "/"))
  }
  return("<unknown>")
}


#' Search the call stack for a first parameter matching a specified class
#'
#' Finds the first instance of a function in the call stack that
#' was called with a object of `.class`. This can be used to find
#' dataframe parameters in tidy calls
#'
#' @param nframe where to start the search
#' @param .class the class name to find
#'
#' @returns a `.class` object
#' @keywords internal
#'
#' @unit
#'
#' h = function() {
#'  df = .search_call_stack(.class = "data.frame")
#'  return(nrow(df))
#' }
#'
#' g = function() {h()}
#'
#' f = function(x) {g()}
#'
#' testthat::expect_equal( f(iris), nrow(iris))
#'
.search_call_stack = function(
  .class,
  nframe = sys.nframe() - 1
) {
  frame = sys.frame(nframe)
  first_arg_name = names(formals(sys.function(nframe)))[[1]]
  try(
    {
      data = suppressWarnings(get(first_arg_name, envir = frame))
      if (inherits(data, .class)) return(data)
    },
    silent = TRUE
  )
  nframe = nframe - 1
  if (nframe < 1) {
    stop(sprintf("no %s found", .class))
  }
  .search_call_stack(.class, nframe)
}


#' Find the package environment for a given environment or function
#'
#' This searches the environment stack looking for the first environment
#' that defines a package. This is the package that the function is defined in.
#' If no namespace environment is found then the function is in the global
#' environment.
#'
#' @param env an environment or function.
#'
#' @returns a namespaced package environment
#' @keywords internal
#'
#' @unit
#'
#' env = .find_namespace(rlang::abort)
#' testthat::expect_equal(unname(getNamespaceName(env)), "rlang")
#'
#' f = function() {"test"}
#' testthat::expect_null(.find_namespace(f))
#'
.find_namespace = function(env = rlang::caller_env()) {
  if (rlang::is_function(env)) {
    env = rlang::fn_env(env)
  }
  while (!identical(env, emptyenv())) {
    try(
      {
        getNamespaceName(env)
        return(env)
      },
      silent = TRUE
    )
    env <- parent.env(env)
  }
  NULL
}


#' Create a skeleton based on a template
#'
#' @inheritParams .update_fenced_block
#'
#' @returns A character vector of the file skeleton. does not write the file
#' @keywords internal
.create_skeleton = function(
  .template = NULL,
  ...,
  .insert_before = "# insert before ----"
) {
  if (is.null(.template)) {
    return(.insert_before)
  } else {
    tmpl_list = rlang::list2(...)
    tmpl_list = tmpl_list[names(tmpl_list) != ""]
    template_content = paste0(.template, collapse = "\n")
    new_content = whisker::whisker.render(template_content, tmpl_list)
    new_content = unlist(stringr::str_split(new_content, "\\n"))

    if (
      !any(stringr::str_detect(new_content, stringr::fixed(.insert_before)))
    ) {
      new_content = c(new_content, .insert_before)
    }
    return(new_content)
  }
}


#' Update a fenced block within a file with new content based on a template
#'
#' This function looks for a fenced section (typically of code) with markers defined by
#' `.start_glue` and `.end_glue` and replaces them with the evaluated template
#' content. If no matching sections are found the new code is inserted before the
#' matched `.insert_before` marker (or at the end if that is not found)
#'
#' @param .input the input as a character vector
#' @param .template the whisker template as a character vector
#' @param name a name for the block
#' @param ... additional named parameters supplied to the whisker template
#' @param .start_glue a glue specification for the marker of the start of the
#'   block to be replaced. May use any of the whisker variables e.g. `"# {name}
#'   start ----"`. This can also be given as a numeric index, were particularly
#'   0 is the beginning of the input and -1 is the end. If numeric it is start
#'   inclusive.
#' @param .end_glue a glue specification for the marker of the end of the
#'   block to be replaced. May use any of the whisker variables e.g.
#'   `"# {name} end ----"` or numeric as above. If numeric it is end inclusive.
#' @param .insert_before a marker for where in the file to insert a block if no
#'   matching start and end markers are found.
#' @param .parse_fn a function that takes the matching block in the source and
#'   extracts a named list of data from it. The default returns an empty list.
#'
#' @returns A character vector of the updated content of the file. Does not
#'   write the file
#' @keywords internal
#'
#' @examples
#' # double braces in mustache files, single braces in glue specs.
#' template = "# {{name}} {{status}}"
#'
#' input = c(
#'   "before",
#'   "# test start ----",
#'   "# test original",
#'   "# test end ----",
#'   "# insert before ----",
#'   "end"
#' )
#'
#' input = .update_fenced_block(
#'   input, template, name = "test", status = "update",
#'   .start_glue = "# {name} start ----",
#'   .end_glue = "# {name} end ----"
#' )
#'
#' input = .update_fenced_block(
#'   input, template, name = "test2", status = "update",
#'   .start_glue = "# {name} start ----",
#'   .end_glue = "# {name} end ----"
#' )
#'
#' .update_fenced_block(
#'   input, template, name = "test", status = "update",
#'   .start_glue = 2,
#'   .end_glue = "# {name} end ----"
#' )
#'
#'
#'
.update_fenced_block = function(
  .input,
  .template,
  name,
  ...,
  .start_glue = "# {name} start ----",
  .end_glue = "# {name} end ----",
  .insert_before = "# insert before ----",
  .parse_fn = ~ list()
) {
  template_content = paste0(.template, collapse = "\n")

  .parse_fn = rlang::as_function(.parse_fn)

  tmpl_list = rlang::list2(...)
  tmpl_list$name = name
  tmpl_list = tmpl_list[names(tmpl_list) != ""]

  input_lines = unlist(stringr::str_split(.input, "\\n"))

  if (is.numeric(.start_glue)) {
    # Allow start and end to be given as indices.
    # The start is zero, not one.
    start_loc = .start_glue
    start = input_lines[start_loc]
    if (all(start_loc < 0)) start_loc = start_loc + length(.input)
  } else {
    start = glue::glue_data(tmpl_list, .start_glue)
    start_loc = which(stringr::str_detect(input_lines, start))
  }

  if (.start_glue == .end_glue) {
    # Deal with identical start and end fences.
    start_loc = start_loc[seq_along(start_loc) %% 2 == 1]
    end_loc = start_loc[seq_along(start_loc) %% 2 == 0]
  } else {
    if (is.numeric(.end_glue)) {
      # end is given as a numeric.
      # the last line is -1, it is end inclusive.
      end_loc = .end_glue
      end = input_lines[end_loc]
      if (all(end_loc < 0)) end_loc = end_loc + length(.input) + 1
    } else {
      end = glue::glue_data(tmpl_list, .end_glue)
      end_loc = which(stringr::str_detect(input_lines, end))
    }
  }

  if (length(start_loc) == 0 || length(end_loc) == 0) {
    # markers not detected. file maybe empty or markers not present
    insert_loc = which(stringr::str_detect(
      input_lines,
      stringr::fixed(.insert_before)
    ))
    # insert_loc maybe a zero length vector
    start_loc = min(c(length(input_lines), insert_loc)) # insert before (or at end if not found)
    end_loc = min(c(length(input_lines), insert_loc - 1))
  } else if (
    length(start_loc) != 1 || length(end_loc) != 1 || end_loc <= start_loc
  ) {
    stop(
      "Mismatched markers were found between:\n'",
      start,
      "' and \n'",
      end,
      "' in file:\n",
      .input,
      "\nIt is in an inconsistent state and will need manual editing."
    )
  }

  if (start_loc > 0) {
    input_leading = input_lines[seq_len(start_loc - 1)]
    indent = unlist(stringr::str_extract(input_lines[start_loc], "^\\s*"))
    input_matched = input_lines[start_loc:end_loc]
  } else {
    # empty file
    input_leading = character()
    indent = ""
    input_matched = input_lines[seq_len(end_loc)]
  }
  # end_loc maybe zero if at start of file.
  input_trailing = input_lines[-1 * seq_len(end_loc)]

  # Parse existing content and add to template input:
  parsed = .parse_fn(trimws(input_matched))
  tmpl_list = modifyList(parsed, tmpl_list)

  new_block = whisker::whisker.render(template_content, tmpl_list)
  new_block_lines = unlist(stringr::str_split(new_block, "\\n"))

  # top and tail new content and indent
  new_block_lines = paste0(indent, c(start, new_block_lines, end))

  return(c(input_leading, new_block_lines, input_trailing))
}


#' Deletes content between markers in an input
#'
#' This function deletes anything between matching markers in an input vector
#' including the markers themselves. This will match multiple markers if present
#' and paired
#'
#' @inheritParams .update_fenced_block
#'
#' @returns a character vector with the deleted blocks
#' @export
#'
#' @examples
#'
#' tmp = .delete_fenced_block(letters,.start_glue = letters[4], .end_glue = letters[10])
#' testthat::expect_true(!any(letters[4:10] %in% tmp))
#'
#' # multiple copies of fenced block are removed
#' # fenced block to end of file is removed
#' testthat::expect_equal(
#'   .delete_fenced_block(rep(letters,3),.start_glue = "b", .end_glue = "z"),
#'   rep("a",3)
#' )
#'
#' # fenced block at beginning is removed:
#' testthat::expect_equal(
#'   .delete_fenced_block(letters,.start_glue = "a", .end_glue = "y"),
#'   "z"
#' )
#'
#' # fenced block
#' testthat::expect_equal(
#'   .delete_fenced_block(letters,.start_glue = "a", .end_glue = "z"),
#'   character()
#' )
#'
#' testthat::expect_equal(
#'   .delete_fenced_block(letters,.start_glue = 2, .end_glue = -2),
#'   c("a","z")
#' )
.delete_fenced_block = function(
  .input,
  name,
  ...,
  .start_glue = "# {name} start ----",
  .end_glue = "# {name} end ----"
) {
  tmpl_list = rlang::list2(...)
  if (!missing(name)) {
    tmpl_list$name = name
  }

  input_lines = unlist(stringr::str_split(.input, "\\n"))

  if (is.numeric(.start_glue)) {
    # Allow start and end to be given as indices.
    # The start is zero, not one.
    start_loc = .start_glue
    if (all(start_loc < 0)) start_loc = start_loc + length(.input)
  } else {
    start = glue::glue_data(tmpl_list, .start_glue)
    start_loc = which(stringr::str_detect(input_lines, start))
  }

  if (.start_glue == .end_glue) {
    # Deal with identical start and end fences.
    start_loc = start_loc[seq_along(start_loc) %% 2 == 1]
    end_loc = start_loc[seq_along(start_loc) %% 2 == 0]
  } else {
    if (is.numeric(.end_glue)) {
      # end is given as a numeric.
      # the last line is -1, it is end inclusive.
      end_loc = .end_glue
      if (all(end_loc < 0)) end_loc = end_loc + length(.input) + 1
    } else {
      end = glue::glue_data(tmpl_list, .end_glue)
      end_loc = which(stringr::str_detect(input_lines, end))
    }
  }

  if (length(start_loc) == 0 || length(end_loc) == 0) {
    return()
  }

  if (
    length(start_loc) != length(end_loc) ||
      any(end_loc <= start_loc) ||
      any(end_loc >= c(start_loc[-1], Inf))
  ) {
    stop(
      "Mismatched markers were found between:\n'",
      start,
      "' and \n'",
      end,
      "' in file:\n",
      .input,
      "\nIt is in an inconsistent state and will need manual editing."
    )
  }

  select = unlist(lapply(seq_along(start_loc), function(i) {
    -1 * start_loc[i]:end_loc[i]
  }))
  return(input_lines[select])
}

#
#' Extract data from the output of a glue call
#'
#' This function allow for the reverse of the `glue::glue_data()` operation
#' and regenerates the data as a dataframe. It won't work for very complex glue
#' specifications and will only return strings.
#'
#' @param glue_spec a glue spec with braces determining named substitutes
#' @param output the glue output
#'
#' @returns a dataframe with a column per piece which could have been used in
#'   `glue::glue_data(.x,glue_spec)` apart from leading white space.
#' @export
#'
#' @examples
#' glue_spec = "# {name}, {value1} and {value2} ----"
#' output = rep("  # one, two and three ----",5)
#' tmp = .recover_pieces(glue_spec,output)
#'
#' testthat::expect_equal(nrow(tmp), 5)
#' testthat::expect_equal(trimws(output), glue::glue_data(tmp,glue_spec))
#'
.glue_recover_pieces = function(glue_spec, output) {
  names = unlist(stringr::str_extract_all(glue_spec, "(?<=\\{)[^\\}]*(?=\\})"))
  matcher = stringr::str_replace_all(glue_spec, "\\{[^\\}]*\\}", "(.*?)")
  matcher = paste0(c("^", matcher, "$"), collapse = "")
  values = stringr::str_match_all(trimws(output), matcher)
  out = dplyr::tibble(.rows = length(output))
  for (i in seq_along(names)) {
    out[[names[i]]] = sapply(values, function(value) value[1, i + 1])
  }
  return(out)
}


#' Detect glue outputs
#'
#' This allows you to filter for lines that match those that could have been
#' generated with a given glue spec
#'
#' @param glue_spec a glue spec with braces determining named substitutes
#' @param content a character vector
#'
#' @returns a logical vector with true if the character could have been created
#'   by the glue spec.
#' @keywords internal
#'
#' @unit
#' content = c("sdlfksl","  # X, Y and Z ----","sdfskjfsdlk asdlkfjsdlkj")
#' testthat::expect_equal(
#'   .glue_detect_output("# {name}, {value1} and {value2} ----", content),
#'   c(FALSE,TRUE,FALSE)
#' )
.glue_detect_output = function(glue_spec, content) {
  matcher = stringr::str_replace_all(glue_spec, "\\{[^\\}]*\\}", "(.*?)")
  matcher = paste0(c("^", matcher, "$"), collapse = "")
  stringr::str_detect(trimws(content), matcher)
}
